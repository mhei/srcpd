-*- text -*-

Programming of modules for the srcpd

Stand: 2005-10-29

0. Overview

All modules can be used multiply and in parallel. 

All modules are included at compile time. An option
to select them (e.g. via configure) is not available at
this time.

All configuration is done with the srcpd config file. The XML
based format needs some discipline, e.g. with respect to spaces
within busnames (developer task) and file/device names (user task).

1. Startup

During the startup _the_ config file (compile time build in name or
configurable with the -f option) is read. In the file config-srcpd.c
the function register_bus() calls the hard coded functions from the
respective busses with there DOM subtree and there effective bus number.

This parsing route must initialize all data fields it's global
busses array entry and analyse the XML DOM subtree. It should 
provide useful default values.

The framework expects the following call back function pointers to
be set:

- init_bus: called as "SRCP INIT <bus>"
- term_bus: called as "SRCP TERM <bus>"
- send_rec: called as separate thread. That thread works as endless
  loop to communicate with the real hardware (if any) 
- string DESCRIPTION with all supported device groups.

In addition all specific data such as device names etc.


2. init_bus

Is called before the (send_rec)() thread

3. term_bus

Is called after canceling the (send_rec)() thread to cleanup

4. send_rec

endless loop to process the device queries to comminucate with
hardware and read back information. It gets a single parameter:
the bus number. The return type should be void*, it will be ignored
by now.

void* thr_sendrec_LOOPBACK (void *v)
{
  int bus = (int) v;


Can be supervised by a watchdog to detect blocks. In this case
the thread is canceled and restarted. Note that the init_bus/term_bus
function are _not_ called.

5. Watchdog

Not every module may need it. If active, the master process checks
the variable watchdog in the busses-array and sets it to 0 (zero).
If the value found _is_ already 0 (zero) the rend_rec thread is restarted.
A syslog message is generated.

The send_rec thread has to set this watchdog variable constantly to
a value greater than 0.

6. Debugging

Debugging within the srcpd may be tricky dou the potentially many
threads and the lack of a console. To assist _please_ do not use
even temporarily such constructs. Use the function DBG() instead.

This function provides the following user selectable verbosity levels

#define DGB_NONE 0
#define DBG_FATAL 1
#define DBG_ERROR 2
#define DBG_WARN 3
#define DBG_INFO 4
#define DBG_DEBUG 5

A value greater than 5 can be used to disable communication with the
hardware.

7. Sample code

The module loopback (loopback.[hc]) can be used as a starting point
to develop a new modules.

8. Queues

Every device group provides it's own queue for every bus. These
queues are filled from the srcp network code. The queues are simple
first-in-first-out queues.

if(!queue_GA_isempty(bus)) {
    unqueueNextGA(&ga);
    process_single_ga(ga);
    setGA(ga)
}

The function unqueueNext<devicegroup>() unqueues the next command.

The function getNext<devicegroup> can be used to read the next command
without remove it from the queue.

The function set<devicegroup> updates the internal data and and sends
the information to all INFORMATION sessions.

9. Naming Convention

9.1 Function Names

The thread function have names prefixed with thr_. Functions with relation with
SRCP have the command name and the device group in there names (GA, TERM).
Functions used internally by a module have to be declared static. Exported functions
(those in the header file) have to contain the module name in uppercase.
(e.g. readconfig_LOOPBACK for the loopback module)

9.2 Bus parameter

All functions are called with the current bus number. Any remaining
data can be found in the array busses.

9.3 busses-Array

The array busses contains all configuration and working data for the configured
busses. It is currently declared as a static array with 20 entries (0..19).

The data structure reflects the XML configuration structure. Commonly used
data  such as pointer to the functions, watchdog, description string etc and
the bus type is provided. Module specific data (such as data from the XML
subtree) is provided as the (void*) pointer driverdata. This pointer _can_
be NULL.


10. SRCP Hacking

Any changes to the SRCP MUST be in covered by the SRCP specification. No
extensions.

11. Other Operating Systems

Currently the srcpd is very linux specific. Some modules can be used on
other unixoid systems (FreeBSD is known to work). 

OSs which are very different from unix can be supported, but this
will need the respective developer(s). Cygwin is currently on the
way..

12. Use of CVS

Every one is permitted to read (sourceforge updates the public
cvs server with a delay of some hours!). The instructions to
access can be found at http://sourceforge.net/projects/srcpd,
topic CVS

After CVS checkout the first to do is a 

 autoreconf

After that the usual ./configure && make && make install should do
the work.

Who wants to get write access (and immediate read without the delay)
should contact the project admins. 
