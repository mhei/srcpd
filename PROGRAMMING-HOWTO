-*- text -*-

Programmierung von srcpd Modulen

Stand: Herbst/Winter 2002

0. Allgemeines

Alle srcpd Module müssen reentrant programmiert werden. Sie müssen
davon ausgehen, das sie mehrfach mit unterschiedlicher Parametrierung
vorkommen.

Sie werden grundsätzlich statisch eingebunden. Eine configure-option
gibt es (derzeit) nicht.

Die Initialisierung erfolgt ausschließlich über die Konfigurationsdatei
(/etc/srcpd.conf). Das XML Format erfordert einige Disziplin, insbesondere
bei der Wahl der Busbezeichner; und bei Leerzeichen/Leerzeilen.

1. Initialisierung

Beim Parsen der Konfiguration wird je nach Bustyp (der in config-srcpd.*
hinterlegt werden muß) eine Routine mit dem XML Teilbaum und der Busnummer
aufgerufen. In dem globalen Array busses stehen für jeden Bus _seine_
Datenbereiche. Insbesondere müssen dort Pointer auf folgende Funktionen
hinterlegt werden:

- init_bus: Pendant zum SRCP INIT <bus>
- term_bus: Pendant zum SRCP TERM <bus>
- send_rec: Wird als Thread aufgerufen, der nicht terminiert und die
   gesamte Kommunikation mit der konkreten Hardware abwickelt.
- Descriptionstring mit den unterstützten Gerätegruppen

Hinzu kommen Hardwarespezifische Details, wie Gerätename, Anzahl der
jeweils unterstützten Geräte etc.

Die Funktion register_bus() in config-srcpd.c muß entsprechend den bereits
enthaltenen Modulen ergänzt werden.

2. Initialisierung

Wird vor dem Start des Threads aufgerufen. 

3. Terminierung

Wird nach Beendigung des Threads aufgerufen, um aufzuräumen.

4. Thread

Endlosschleife, die die zuständigen Queues abfragt und die anstehenden
Ausgaben zur Hardware auszuführen. Daneben auch verantwortlich für das
Einlesen der Hardwareangaben, um sie dem Framework zurückzumelden.

Kann vom Wachhund überwacht werden, um Hänger zu erkennen. Dann wird
der Thread gecancelt und neu gestartet. Eine Ausführung der TERM/INIT
Sequenz ist dabei _nicht_ vorgesehen.

5. Watchdog

Nicht jeder Thread braucht den. Wenn aktiviert, wird vom Masterthread
laufend eine Variable watchdog im Array busses abgefragt. Steht diese
auf 0, wird der Thread neu gestartet. Gleichfalls wird bei jeder Abfrage
diese Variable auf 0 gesetzt. Es ist am Thread, diese ständig auf
einen anderen Wert zu setzen.

6. Debugging

Debugging der bestehenden Threads erfolgt via DBG() anstelle von
printf(). Hierbei ist der Vebositylevel zu beachten. Vordefinierte
Werte sind

#define DGB_NONE 0
#define DBG_FATAL 1
#define DBG_ERROR 2
#define DBG_WARN 3
#define DBG_INFO 4
#define DBG_DEBUG 5

Bei Werten größer 5 kann eine direkte Kommunikation mit der Hardware
unterbleiben.

7. Beispielcode

Die Datei loopback.[ch] sind als Dummygeräte ohne wirklich Hardware
und als Ausgangspunkt für eigene Entwicklungen geeignet.

8. Queues

Jede Gerätegruppe hat auf jedem Bus eine eigene Queue, die von den
SRCP Netzwerkroutinen gefüllt wird. 

Sinnvoll ist die eigentlich nur bei GA und GL (m.E. FB). 
Andere Gerätegruppen brauchen die nicht.

if(!queue_GA_isempty(bus)) {
    unqueueNextGA(&ga);
    process_single_ga(ga);
    setGA(ga)
}

Die Routine unqueueNextGA() (sinngemäß für die restlichen Gerätegruppen)
liest den als nächstes auszuführende GA-Befehl aus und entfernt ihn aus
der Queue. Die Queue ist eine simple First-In-First-Out Queue.

Mit der Funktion getNextGA läßt sich der nächste Befehl auslesen, _ohne_
ihn aus der Queue selbst zu entfernen.

setGA aktualisiert alle internen Daten und veranlasst das Kundtun auf
den Infokanälen.

9. Namenskonventionen

9.1 Funktionsnamen

Die Threads haben mit thr_ beginnende Funktionsnamen. Kommandos mit Bezug zum
SRCP haben den betreffenden Bezug im Namen (GA, TERM). Funktionen, die nur im
Modul selbst Sinn haben, werden static deklariert. Exportierte Funktionen haben
grundsätzlich den Gerätenamen zu enthalten (z.B. readconfig_M6051 für das 6051 
von Märklin)

9.2 Busparameter

Alle Funktionen werden vom Framework mit der wirksamen Busnummer aufgerufen.
Damit lassen sich die busspezifischen Angaben auf dem busses[] Array auslesen.

9.3 busses-Array

Der Array busses ist zum einen generisch, enthält aber einen Bustypspezifischen
Datenteil. Der allg. Teil umfaßt die Pointer auf die Funktionen, allg Parameter
(Watchdog, Description) und eine Typspezifikation. Hinzu kommt ein Pointer auf
driverspezifische Daten, der auch NULL sein kann.

Es ist ein primitives OO Design (im Sinne von Klassenvererbung) damit verbunden.

10. SRCP Hacking

Nur entsprechend der SRCP Spezifikation. Keine eigenmächtigen Veränderungen.

11. Andere Betriebssysteme

Sollten nicht ignoriert werden. Linux (aktuell zudem) ist aber Schwerpunkt.
Portabel geht aber vor genial. Ein 386er kann, muß aber nicht ausreichen.

OS, die wesentlich von Unix abweichen, kommen später; vielleicht.

FreeBSD ist zumindest teilweise (d.h. bei derjenigen Hardware, die nicht
allzuweit vom PC angesiedelt ist) unterstützt

12. CVS Benutzung.

Lesen darf jeder. Anleitung findet sich auf 
http://sourceforge.net/projects/srcpd, Rubrik CVS

Das erste, was nach einem CVS Checkout ansteht, ist ein

make -f Makefile.dist

Damit wird das autoconf System initialisiert und steht für den configure-
Lauf bereit.

Wer CVS Schreibrechte haben möchte, wende sich an den/die Projektbetreuer.
